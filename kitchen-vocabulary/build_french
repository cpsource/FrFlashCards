#!/bin/bash
# Auto-generated from CSV by generate_build_french.py
# Usage:
#   export OPENAI_API_KEY=sk-...
#   chmod +x build_french
#   ./build_french

set -euo pipefail

LOG_FILE="build_french.log"
VOICE="alloy"
FORMAT="mp3"
MODEL="gpt-4o-mini-tts"

echo "Starting French build..." | tee "$LOG_FILE"

# --- spoon ---
ENG="spoon"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/spoon.jpg"
FRENCH_TEXT="Ceci est la cuillère."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est la cuillère.'
OUT = "spoon.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- fork ---
ENG="fork"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/fork.jpg"
FRENCH_TEXT="Ceci est la fourchette."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est la fourchette.'
OUT = "fork.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- knife ---
ENG="knife"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/knife.jpg"
FRENCH_TEXT="Ceci est le couteau."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est le couteau.'
OUT = "knife.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- plate ---
ENG="plate"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/plate.jpg"
FRENCH_TEXT="Ceci est l’assiette."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est l’assiette.'
OUT = "plate.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- bowl ---
ENG="bowl"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/bowl.jpg"
FRENCH_TEXT="Ceci est le bol."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est le bol.'
OUT = "bowl.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- glass ---
ENG="glass"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/glass.jpg"
FRENCH_TEXT="Ceci est le verre."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est le verre.'
OUT = "glass.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- cup ---
ENG="cup"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/cup.jpg"
FRENCH_TEXT="Ceci est la tasse."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est la tasse.'
OUT = "cup.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- napkin ---
ENG="napkin"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/napkin.jpg"
FRENCH_TEXT="Ceci est la serviette."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est la serviette.'
OUT = "napkin.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- straw ---
ENG="straw"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/straw.jpg"
FRENCH_TEXT="Ceci est la paille."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est la paille.'
OUT = "straw.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- dish ---
ENG="dish"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/dish.jpg"
FRENCH_TEXT="Ceci est le plat."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est le plat.'
OUT = "dish.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- pan ---
ENG="pan"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/pan.jpg"
FRENCH_TEXT="Ceci est la poêle."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est la poêle.'
OUT = "pan.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- pot ---
ENG="pot"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/pot.jpg"
FRENCH_TEXT="Ceci est la casserole."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est la casserole.'
OUT = "pot.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- lid ---
ENG="lid"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/lid.jpg"
FRENCH_TEXT="Ceci est le couvercle."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est le couvercle.'
OUT = "lid.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- spatula ---
ENG="spatula"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/spatula.jpg"
FRENCH_TEXT="Ceci est la spatule."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est la spatule.'
OUT = "spatula.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- whisk ---
ENG="whisk"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/whisk.jpg"
FRENCH_TEXT="Ceci est le fouet."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est le fouet.'
OUT = "whisk.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- ladle ---
ENG="ladle"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/ladle.jpg"
FRENCH_TEXT="Ceci est la louche."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est la louche.'
OUT = "ladle.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- cutting board ---
ENG="cutting_board"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/cutting_board.jpg"
FRENCH_TEXT="Ceci est la planche à découper."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est la planche à découper.'
OUT = "cutting_board.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- grater ---
ENG="grater"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/grater.jpg"
FRENCH_TEXT="Ceci est la râpe."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est la râpe.'
OUT = "grater.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- peeler ---
ENG="peeler"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/peeler.jpg"
FRENCH_TEXT="Ceci est l’éplucheur."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est l’éplucheur.'
OUT = "peeler.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- colander ---
ENG="colander"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/colander.jpg"
FRENCH_TEXT="Ceci est la passoire."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est la passoire.'
OUT = "colander.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- rolling pin ---
ENG="rolling_pin"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/rolling_pin.jpg"
FRENCH_TEXT="Ceci est le rouleau à pâtisserie."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est le rouleau à pâtisserie.'
OUT = "rolling_pin.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- oven mitt ---
ENG="oven_mitt"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/oven_mitt.jpg"
FRENCH_TEXT="Ceci est le gant de cuisine."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est le gant de cuisine.'
OUT = "oven_mitt.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- stove ---
ENG="stove"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/stove.jpg"
FRENCH_TEXT="Ceci est la cuisinière."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est la cuisinière.'
OUT = "stove.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- oven ---
ENG="oven"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/oven.jpg"
FRENCH_TEXT="Ceci est le four."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est le four.'
OUT = "oven.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- microwave ---
ENG="microwave"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/microwave.jpg"
FRENCH_TEXT="Ceci est le micro-ondes."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est le micro-ondes.'
OUT = "microwave.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- refrigerator ---
ENG="refrigerator"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/refrigerator.jpg"
FRENCH_TEXT="Ceci est le réfrigérateur / le frigo."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est le réfrigérateur / le frigo.'
OUT = "refrigerator.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- freezer ---
ENG="freezer"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/freezer.jpg"
FRENCH_TEXT="Ceci est le congélateur."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est le congélateur.'
OUT = "freezer.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- dishwasher ---
ENG="dishwasher"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/dishwasher.jpg"
FRENCH_TEXT="Ceci est le lave-vaisselle."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est le lave-vaisselle.'
OUT = "dishwasher.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- toaster ---
ENG="toaster"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/toaster.jpg"
FRENCH_TEXT="Ceci est le grille-pain."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est le grille-pain.'
OUT = "toaster.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- blender ---
ENG="blender"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/blender.jpg"
FRENCH_TEXT="Ceci est le mixeur / le blender."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est le mixeur / le blender.'
OUT = "blender.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- coffee maker ---
ENG="coffee_maker"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/coffee_maker.jpg"
FRENCH_TEXT="Ceci est la cafetière."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est la cafetière.'
OUT = "coffee_maker.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- kettle ---
ENG="kettle"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/kettle.jpg"
FRENCH_TEXT="Ceci est la bouilloire."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est la bouilloire.'
OUT = "kettle.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- knife block ---
ENG="knife_block"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/knife_block.jpg"
FRENCH_TEXT="Ceci est le bloc à couteaux."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est le bloc à couteaux.'
OUT = "knife_block.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- jar ---
ENG="jar"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/jar.jpg"
FRENCH_TEXT="Ceci est le bocal."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est le bocal.'
OUT = "jar.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- bottle ---
ENG="bottle"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/bottle.jpg"
FRENCH_TEXT="Ceci est la bouteille."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est la bouteille.'
OUT = "bottle.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- container ---
ENG="container"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/container.jpg"
FRENCH_TEXT="Ceci est le récipient."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est le récipient.'
OUT = "container.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- lid (for jars) ---
ENG="lid_for_jars"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/lid_for_jars.jpg"
FRENCH_TEXT="Ceci est le couvercle."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est le couvercle.'
OUT = "lid_for_jars.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- shelf ---
ENG="shelf"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/shelf.jpg"
FRENCH_TEXT="Ceci est l’étagère."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est l’étagère.'
OUT = "shelf.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- drawer ---
ENG="drawer"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/drawer.jpg"
FRENCH_TEXT="Ceci est le tiroir."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est le tiroir.'
OUT = "drawer.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- cupboard ---
ENG="cupboard"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/cupboard.jpg"
FRENCH_TEXT="Ceci est le placard."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est le placard.'
OUT = "cupboard.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- counter ---
ENG="counter"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/counter.jpg"
FRENCH_TEXT="Ceci est le plan de travail."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est le plan de travail.'
OUT = "counter.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- sink ---
ENG="sink"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/sink.jpg"
FRENCH_TEXT="Ceci est l’évier."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est l’évier.'
OUT = "sink.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- sponge ---
ENG="sponge"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/sponge.jpg"
FRENCH_TEXT="Ceci est l’éponge."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est l’éponge.'
OUT = "sponge.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- dish soap ---
ENG="dish_soap"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/dish_soap.jpg"
FRENCH_TEXT="Ceci est le liquide vaisselle."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est le liquide vaisselle.'
OUT = "dish_soap.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- towel ---
ENG="towel"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/towel.jpg"
FRENCH_TEXT="Ceci est le torchon."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est le torchon.'
OUT = "towel.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- trash can ---
ENG="trash_can"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/trash_can.jpg"
FRENCH_TEXT="Ceci est la poubelle."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est la poubelle.'
OUT = "trash_can.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- broom ---
ENG="broom"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/broom.jpg"
FRENCH_TEXT="Ceci est le balai."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est le balai.'
OUT = "broom.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

# --- mop ---
ENG="mop"
IMG_URL="https://commons.wikimedia.org/wiki/Special:FilePath/mop.jpg"
FRENCH_TEXT="Ceci est la serpillière."

echo "▶ Processing ${ENG} ..." | tee -a "$LOG_FILE"

# 1) Try full run (image + audio). Never abort overall flow.
python3 get_frflashy_image_and_sound.py \
  --image "$IMG_URL" \
  --french-text "$FRENCH_TEXT" \
  --voice "$VOICE" \
  --format "$FORMAT" \
  --model "$MODEL" \
  --outfile-prefix "$ENG" \
  2>&1 | tee -a "$LOG_FILE" || true

# 2) Resize PNG if present
if [ -f "${ENG}.png" ]; then
  echo "   Found PNG → resizing to 100 px" | tee -a "$LOG_FILE"
  python3 ../tools/resize_png-2.py "${ENG}.png" 100 2>&1 | tee -a "$LOG_FILE" || true
else
  echo "⚠️  No PNG for ${ENG} (image may have failed)." | tee -a "$LOG_FILE"
fi

# 3) Ensure MP3 exists and is non-empty; if not, rebuild audio ONLY with a robust inline helper
if [ ! -s "${ENG}.mp3" ]; then
  echo "⚠️  ${ENG}.mp3 missing or zero-bytes — retrying audio-only..." | tee -a "$LOG_FILE"
  rm -f "${ENG}.mp3"

  # Inline Python fallback: generate MP3 regardless of image result
  python3 - << 'PY' 2>&1 | tee -a "$LOG_FILE" || true
import os, sys, base64, pathlib
FRENCH_TEXT = 'Ceci est la serpillière.'
OUT = "mop.mp3"
VOICE = os.environ.get("VOICE","alloy")
MODEL = os.environ.get("MODEL","gpt-4o-mini-tts")

try:
    from openai import OpenAI
except Exception as e:
    print("[ERROR] Fallback TTS: openai package missing:", e)
    sys.exit(0)

def write_bytes(path, b):
    pathlib.Path(path).write_bytes(b if isinstance(b, (bytes, bytearray)) else bytes(b))

client = OpenAI()

# Strategy A: Responses API (modalities audio)
try:
    r = client.responses.create(
        model=MODEL,
        input=FRENCH_TEXT,
        modalities=["text","audio"],
        audio={"voice": VOICE, "format": "mp3"},
    )
    # extract base64 audio
    def _extract(resp):
        try:
            d = resp if isinstance(resp, dict) else resp.model_dump()
            for blk in d.get("output", []):
                for item in blk.get("content", []):
                    aud = item.get("audio")
                    if aud and aud.get("data"):
                        return base64.b64decode(aud["data"])
        except Exception:
            pass
        # object-attr style
        try:
            for blk in getattr(resp, "output", []) or []:
                for it in getattr(blk, "content", []) or []:
                    aud = getattr(it, "audio", None)
                    if aud and getattr(aud, "data", None):
                        return base64.b64decode(aud.data)
        except Exception:
            pass
        return None
    data = _extract(r)
    if data:
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via Responses API →", OUT)
            sys.exit(0)
except Exception:
    pass

# Strategy B: classic audio.speech.create with either format= or response_format=
try:
    try:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(format=) →", OUT)
            sys.exit(0)
    except TypeError:
        resp = client.audio.speech.create(model=MODEL, voice=VOICE, input=FRENCH_TEXT, response_format="mp3")
        data = resp.read() if hasattr(resp, "read") else getattr(resp, "content", resp)
        write_bytes(OUT, data)
        if os.path.getsize(OUT) > 0:
            print("[OK] Audio fallback via audio.speech.create(response_format=) →", OUT)
            sys.exit(0)
except Exception as e:
    print("[WARN] Audio fallback failed:", e)

print("[ERROR] Audio fallback could not produce a valid mp3 for", OUT)
PY

  # Verify again after fallback
  if [ ! -s "${ENG}.mp3" ]; then
    echo "❌ FAILED to produce non-empty MP3 for ${ENG}" | tee -a "$LOG_FILE"
  else
    echo "✅ Recovered MP3 for ${ENG}" | tee -a "$LOG_FILE"
  fi
else
  echo "   MP3 OK for ${ENG}" | tee -a "$LOG_FILE"
fi

echo "✅ Completed ${ENG}" | tee -a "$LOG_FILE"

echo "All entries processed. See build_french.log for details."
